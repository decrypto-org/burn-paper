\section{Consumption}

We now describe how a smart contract on the target blockchain can verify that a burn has taken place on the source blockchain. Note how this puts a constraint on the target blockchain to have smart contract capabilities, however there is no such constraint for the source blockchain. Such a mechanism allows a target cryptocurrency to bootstrap through burns on another source blockchain as outlined in Section~\ref{section:introduction}.

A user who wishes to acquire a target cryptocurrency first has to form burn address which encodes her receiving address on the target blockchain. The user then sends an amount of the source cryptocurrency to that address. She then proceeds to submit a proof of this burn on the target blockchain, where the burn is verified and the user is credited an equivalent amount of target cryptocurrency on her receiving address.

In accordance to the terminology laid out in~\cite{pow-sidechains}, we call this party the \emph{prover} and we call the smart contract the \emph{verifier}.

We abstract the functionalities regarding transactions on the source blockchain into a \emph{blockchain transaction protocol}.

\begin{definition}[Blockchain transaction protocol]\label{def:blockchain-tx}
  A \emph{blockchain transaction protocol} $\Pi_\zeta$ consists of two functions $\VerTxIncl$ and $\TxHasTransfer$.

  \begin{itemize}
    \item $\VerTxIncl(b, tx, \tau)$: Given block $b$, transaction $tx$ and a proof $\tau$, return $\true$ if $\tau$ is a valid proof for the fact that $tx \in b$.
    \item $\TxHasTransfer(tx, addr, amount)$: Given transaction $tx$, an address $addr$ and an amount, return $\true$ if $tx$ contains a value transfer of the specified amount towards the specified address.
  \end{itemize}
\end{definition}

More concretely, in Bitcoin, each block header contains a commitment to the set of transaction ids in the block in the form of a Merkle Tree root. Thus, for Bitcoin the proof $\tau$ for $\VerTxIncl$ is a Merkle Tree inclusion proof. Ethereum stores a similar commitment in its header, in the form of the root of a Merkle-Patricia Trie~\cite{wood2014ethereum}.

For a verifier to be convinced that a burn has taken place on a source blockchain, they need to ensure that the burn is contained in a transaction which belongs to the source blockchain. Specifically, the following data need to be supplied to the smart contract:

\begin{itemize}
  \item \textsf{tx}: The transaction which contains the burn on the source blockchain.
  \item \textsf{blk}: The block where the aforementioned transaction is contained.
  \item \textsf{txInclusion}: An inclusion proof showing that $\mathsf{tx} \in \mathsf{blk}$ such that $\VerTxIncl(\textsf{blk}, \textsf{tx}, \textsf{txInclusion}) = \true$.
  \item \textsf{blockConnection}: A proof that \textsf{blk} is contained in the best source blockchain.
\end{itemize}

Putting these together, the final proof is the tuple $\beta = \sf(tx, txInclusion, blk, blockConnection)$.

\subsection{Proof-of-Work Sidechains}
Transferring value from a source to a target blockchain has already been a subject of research. A mechanism for the so-called 1-way pegs is described in~\cite{pow-sidechains}. A 1-way peg is established when there is the ability to transfer an amount of source cryptocurrency to a target blockchain in a trustless manner, as we wish to do. Generally, the prover wishes to convince the verifier that an event has taken place on the source blockchain. In that work, an event describes a Solidity event emitted by a smart contract on some chain. It is described as a triplet $e = (chain, contract, aux)$, where $chain$ is an identifier for the chain, $contract$ refers to the address of the contract and $aux$ contains the parameters of the event emitted.

The contract \textsf{crosschain} is defined, which is initialized with the genesis block of the other blockchain $\mathcal{G}$. This contract is responsible for receiving, verifying and then storing events on the other blockchain. It relies on a function $\mathsf{verify}^{e,\mathcal{G}}(\mathcal{P})$, where $\mathcal{P}$ is a set of proofs for the event, which returns $\true$ if and only if the event is valid based on the set of proofs provided.

\begin{itemize}
  \item $\textsf{submit-event-proof}(\pi, e)$: A prover calls this function while putting down a collateral $z$ with an event $e$ and a proof of it $\pi$. The function determines if the proof provided is valid by making use of the \textsf{verify} method. If the proof is valid, a contestation period of $k$ blocks begins where other provers may submit a contesting proof.
  \item $\textsf{submit-contesting-proof}(\pi^*, e)$: A prover calls this function if they have a contesting proof for the proof provided previously for event $e$. If through the use of \textsf{verify} it is discovered that the original prover was dishonest her collateral gets transferred to the caller of this function and the event discarded.
  \item $\textsf{finalize-event}(e)$: A prover calls this function when the contestation period has passed for their event $e$. If there has been no successful contesting prover in the meantime, their event is saved in the set of finalized events on the smart contract.
  \item $\textsf{event-exists}(e)$: A user of the contract calls this function to determine whether an event $e$ has been proven and finalized.
\end{itemize}

A \textsf{sidechain} contract is then defined, which inherits from the \textsf{crosschain} contract all its abilities for event verification. It also allows a user to claim tokens due to some finalized event, and emits events for consumption of the contract on the other blockchain. Specifically, the scheme works by making use of two smart contracts, one called $\mathsf{sidechain}_1$ on the source blockchain and another called $\mathsf{sidechain}_2$ on the target blockchain. In order for a user to send an amount from to a address on the target blockchain, she pays to the \textsf{deposit} method on $\mathsf{sidechain}_1$ while passing in the address on the target blockchain as an parameter. The contract then emits an event $\textsf{Deposited}_1$ which contains the target address, the amount and some auxilary data. A prover, who could be the user herself, then submits the event along with a proof to $\mathsf{sidechain}_2$ according to the aforementioned procedure. Once the event is verified and finalized, the user calls the $\textsf{withdraw}$ method on $\mathsf{sidechain}_2$ while passing in the amount, the address they wish to receive the funds on, and the auxilary data.

We adapt a modified version of this scheme for our purposes, to achieve our own 1-way peg by making use of Proof-of-Burn. Since we may be dealing with a source blockchain which doesn't have smart contract functionality, we cannot rely on events being smart contract events. Thus, we define our event as a simple value transfer described by (a) a transaction id \textsf{txid}, (b) a receiving address \textsf{receiver} and (c) an amount \textsf{amount}. Thus our event takes the form of the tuple $e = (\textsf{txid}, \textsf{receivingAddress}, \textsf{amount})$. We remark that simple value transfers are supported by all popular cryptocurrencies, allowing a verifier to process burns from a wide range of source blockchains. We also remark that for now this event type does not yet distinguish between burn and non-burn addresses. Changing the type of event a verifier verifies of course means that the verification function $\textsf{verify}$ also needs to be defined appropriately.

\import{./}{algorithms/alg.verify-tx.tex}

Before looking at how the verification works for the whole proof $\beta$ we focus on the part of the proof pertaining to the transaction, specifically $\alpha = \sf(tx, txInclusion, blk)$. Verifying this part of the proof for some event $e$ is straightforward by making use of the blockchain transaction protocol in Definition~\ref{def:blockchain-tx}. We ensure that the transaction \textsf{tx} indeed contains the value transfer claimed in the provided event $e$, and that the transaction is really contained in the block provided. The function, \textsf{verify-tx}, can be seen in detail in Algorithm~\ref{alg.verify-tx}.

\begin{definition}[Merkle Tree protocol]
  A \emph{merkle tree} protocol $\mathcal{MT}$ consists of two functions $\mathcal{MT}_t(x_1, \dots, x_t)$ and $\VerMT_t(root, x, \pi)$ which work as follows:

  \begin{itemize}
    \item $\mathcal{MT}_t(x_1, \dots, x_t)$: Given elements $x_1, \dots, x_t$, return the root of the Merkle Tree with exactly $t$ leaves, where for each $1 \le i \le t$, the $i$-th leaf corresponds to $x_i$.

    \item $\VerMT(root, x, \pi)$: Given a Merkle Tree root, an element $x$ and an inclusion proof $\pi$, return $\sf{true}$ if and only if $\pi$ is a valid proof for the fact that $x$ is contained in the tree rooted at $root$.
  \end{itemize}
\end{definition}

\import{./}{algorithms/alg.verify-event-federation.tex}

Now that the issue of verifying the transaction is covered, we move our attention to the issue of verifying that the provided block \textsf{blk} really belongs to the best source blockchain. Let us assume that the smart contract holds in its state the continuously updated set of all valid blocks on the best source blockchain, in the form of a Merkle Tree root $\mathcal{M}$. Then, by verifying a Merkle Tree inclusion proof \textsf{blockConnection} for $\textsf{blk} \in \mathcal{M}$, such that $\VerMT(\mathcal{M}, \textsf{blk}, \textsf{blockConnection}) = \true$, a verifier can be certain that the block provided is indeed part of the best source blockchain. Combined with verifying the transaction this completes our $\textsf{verify}_\mathcal{M}^e$ function, shown in Algorithm~\ref{alg.verify-event-federation}.

We now address the final issue of maintaining an up-to-date set of blocks in the form of $\mathcal{M}$. We propose a federation mechanism of source blockchain full nodes that monitor the source chain and vote for the new set of source chain blocks, if and when it changes. A majority of votes is necessary for $\mathcal{M}$ to be updated on the target blockchain. In this manner, the federation federation acts as a bridge from the source to the target blockchain.

We propose encoding the honestly adopted chain by using a Merkle Mountain Ranges (MMRs)~\cite{flyclient}. Specifically, to generate a checkpoint we take all the chain's block ids in sequence and use them as leaves in a Merkle Mountain Range. We then use the root of that MMR as our encoding. Our rationale for using MMRs instead of other kinds of Merkle Trees is that we expect the most frequent modifications to the tree to be appends (when the source chain is extended by one block), which is a very efficient operation to perform on an existing MMR.

An interesting observation is that, because the federation majority is trusted on the target blockchain, we could avoid hashing block headers in order to verify block connection. Instead of storing the block id of each block in the MMR, we could store the transaction merkle root of each block, and again use the root of the MMR as the checkpoint. The verifier on the smart contract side would then verify that the \textsf{txIDMerkleRoot} provided exists in the MMR using the \textsf{blockConnection}.

\subsection{Bootstraping Mechanism}
\import{./}{algorithms/alg.burn-verifier.tex}

Being able to verify events, we can finally make use of verified events in order to grant target cryptocurrency to users who burn source cryptocurrency. After burning on the source blockchain, the user needs to complete the event submission through \textsf{submit-event-proof} as described earlier. After the event is verified successfully and finalized, the user calls the \textsf{claim} function with the forementioned event. This function ensures that the event provided is finalized and has not been claimed before (i.e. noone has been granted target cryptocurrency for this specific event in the past). Then, after verifying through $\BurnVerify$ that the receiving address of the event is a burn address where the tag is the function caller's address, it releases the amount of coins burned in the form of an ERC-20 token. We present a contract with this capability in Algorithm~\ref{alg.burn-verifier} which we call the \textsf{burn-verifier}.

In the interest of keeping this implementation generic we assume that the user receives a token in return for his burn. However, instead of minting a token, the target cryptocurrency could allow the burn verifier contract to mint native cryptocurrency for any user who successfully claims an event. This would allow the target cryptocurrency to be bootstrapped entirely though burning as desired.

%The workflow is as follows. Once the user has created a burn transaction on the source blockchain, he submits the event along with a proof to the \textsf{submit-event-proof} function. The proof can be either using the MMR approved by the federation or NIPoPoWs, depending on the deployment of the smart contract. Subsequently, he needs to wait for a contestation period of $k$ blocks. Any party who wishes to dispute the proof can do so within this period by calling the \textsf{submit-contesting-proof} function. After the period has passed, the user can finalize the event by calling the \textsf{finalize-event} method.

\subsection{Decentralized Block Connection}
We introduce a second way for proving and verifying the block connection which does not require a trusted federation. This is possible by making use of NIPoPoW infix proofs. The way the proving process works differs quite a bit from the federation, because in the federation there is a trusted source of truth -the federation majority- who vouch for the set of blocks on the source chain. Additionally, if a checkpoint is voted by the federation majority and a valid block connection proof based on that checkpoint is provided, it cannot be disputed.

A NIPoPoW however can be disputed. For example, a malicious verifier could provide an infix proof for a block on a minority chain. In that case, a honest prover would have to step in and provide a proof for the best chain, which the verifier would then compare with the original proof to detect the fraud. For our decentralized approach, we assume a model where there exist two provers, one honest and one malicious similar to~\cite{nipopows,flyclient}. The block connection proof is a NIPoPoW infix proof for the block which includes the burn transaction.

\import{./}{algorithms/alg.verify-event-nipopow.tex}

The NIPoPoW event verifier is very similar to the federated event verifier presented in Algorithm~\ref{alg.verify-event-federation}, with two differences. First, it takes as a parameter a set of proofs $\mathcal{P}$ instead of a single proof as in the case of the federation. Second, after completing the transaction verification it delegates to the NIPoPoW infix proof verification function \textsf{verify-infix}. The NIPoPoW event verifier is illustrated in Algorithm~\ref{alg.verify-event-nipopow}.
