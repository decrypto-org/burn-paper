\section{Consumption}

We now describe how the target blockchain can verify a burn which happened on the source blockchain. Specifically, we study the case of Bitcoin and Ethereum as source blockchains. We define a party which we call a \emph{prover} who is responsible for constructing a proof of the event and sending it to the target blockchain. The proof we need to send is one of transaction inclusion in the honestly adopted chain of the source blockchain. We denote this proof as a triplet $\beta = \sf(tx, txInclusion, blk, blockConnection)$.

\begin{definition}[Merkle Tree protocol]
  A \emph{merkle tree} protocol $\mathcal{MT}$ consists of two functions $\mathcal{MT}_t(x_1, \dots, x_t)$ and $\VerMT_t(root, x, \pi)$ which work as follows:

  \begin{itemize}
    \item $\mathcal{MT}_t(x_1, \dots, x_t)$: Given elements $x_1, \dots, x_t$, return the root of the Merkle Tree with exactly $t$ leaves, where for each $1 \le i \le t$, the $i$-th leaf corresponds to $x_i$.

    \item $\VerMT(root, x, \pi)$: Given a Merkle Tree root, an element $x$ and an inclusion proof $\pi$, return $\sf{true}$ if and only if $\pi$ is a valid proof for the fact that $x$ is contained in the tree rooted at $root$.
  \end{itemize}
\end{definition}

\subsection{Transaction Inclusion Proof}

For simplicity we abbreviate the transaction inclusion part of the complete proof as $\alpha = \sf(tx, txInclusion, blk)$.

\import{./}{algorithms/alg.verify-tx.tex}

The transaction inclusion proof is defined by both Bitcoin and Ethereum. In Bitcoin, each block header contains a commitment to the set of transaction ids in the block in the form of a Merkle Tree root. Thus, for Bitcoin our transaction inclusion proof is of the form $\mathsf{txInclusion} = (\mathsf{txIDMerkleRoot}, \mathsf{txIDMerkleProof})$. The shape of the proof is as follows: $\mathsf{txIDMerkleProof} = ([x_0, x_1, \dots], \mathsf{txIndex}, \mathsf{txCount})$.

Ethereum stores a similar commitment in its header, in the form of the root of a Merkle-Patricia Trie~\cite{wood2014ethereum}. This trie contains the transactions of the block, using the transaction id of each transaction as a key to determine the path to follow starting from the root in order to arrive at that transaction. Similar to regular Merkle trees, Merkle-Patricia tries allow for leaf inclusion proofs.

The verification algorithm for $\alpha$ is presented in Algorithm~\ref{alg.verify-tx}. At the heart of the verification is the function \textsf{containsTransfer}, which takes a transaction, an address and an amount and determines if a value transfer of that exact amount to the address provided has occurred inside the transaction provided. For Bitcoin, this function locates a P2PKH output with the exact amount and receiving address. For Ethereum, the function ensures that the transaction comprises a fund transfer (i.e. the \textsf{data} field is empty), to the receiving address provided and with the exact amount. If this check passes and the transaction inclusion proofs are valid, \textsf{verify-tx} function accepts the proof $\alpha$ for the specified event $e$.

\subsection{Block Connection Proof}

We look at two ways of proving block connection to the honestly adopted source chain.

\subsubsection{Federation}
A federation of $m$ nodes is picked. A federation node is responsible for running the source blockchain software and knowing at every moment the honestly adopted source blockchain. More importantly, it is responsible for transmitting this information to the target blockchain. In order to do this, we define a smart contract on the target blockchain where federation nodes are allowed to submit such information. We call this contract the \textsf{TagRepository}. A federation node encodes the honestly adopted chain into a tag and submits this tag to the \textsf{TagRepository}. Once a majority of votes is achieved, the tag is considered valid for use.

We propose encoding the honestly adopted chain by using a Merkle Mountain Ranges (MMRs)~\cite{flyclient}. Specifically, to generate a tag we take all the chain's block ids in sequence and use them as leaves in a Merkle Mountain Range. We then use the root of that MMR as our encoding.

Knowing this, it is now possible to define \textsf{blockConnection}. This component is an MMR proof for the fact that that $id(\mathsf{blk}) \in \text{MMR}$ in the form of $\mathsf{blockConnection} = [(x_0, s_0), (x_1, s_1), \dots]$, where $s_i \in \sf\{Left, Right\}$.

An interesting observation is that, because the federation majority is trusted on the target blockchain, we could avoid doing the block header hashing and verification in order to verify block connection. Instead of storing the block id of each block in the MMR, we could store the transaction merkle root of each block, and again use the root of the MMR as the tag. The verifier on the smart contract side would then verify that the \textsf{txIDMerkleRoot} provided exists in the MMR using the \textsf{blockConnection}.

\import{./}{algorithms/alg.verify-event-federation.tex}

\subsubsection{Decentralized}
We introduce a second way for proving and verifying the block connection which does not require a trusted federation. This is possible by making use of NIPoPoWs. The way the proving process works differs quite a bit from the federation, because in the federation there is a trusted source of truth. If a tag is voted by the federation majority, then it is forever true. But if this the verifier does not have this information, then it has to rely on the prover to get it. We assume a model where there exist two provers, one honest and one malicious. The block connection proof can be an NIPoPoW infix proof for the block which includes the burn transaction. Specifically, $\mathsf{blockConnection} = \pi\chi$.

\import{./}{algorithms/alg.verify-event-nipopow.tex}

However, this alone is not enough to persuade a verifier. It is possible that the prover is malicious and this proof is constructed for a non-honestly adopted chain (e.g. a temporary adversarial fork). In order for the verifier to be certain, it needs to allow for a honest prover to claim a better proof for a longer chain.

\subsection{Smart Contract Implementation}
\import{./}{algorithms/alg.burn-verifier.tex}

We present a smart contract in Algorithm~\ref{alg.burn-verifier} which we call the \textsf{burn-verifier}. The \textsf{burn-verifier} verifies burn events from the source chain. The contract extends the \textsf{crosschain} contract from \cite{pow-sidechains}. The \textsf{crosschain} contract is responsible for registering events on the source blockchain and verifying them. For our application, we parameterise \textsf{crosschain} with a \textsf{verify} function. The function presented in Algorithm~\ref{alg.verify-event-federation} can be used in a federated setup, and the function presented in Algorithm~\ref{alg.verify-event-nipopow} can be used in a decentralized setup.

The workflow is as follows. Once the user has created a burn transaction on the source blockchain, he submits the event along with a proof to the \textsf{submit-event-proof} function. The proof can be either using the MMR approved by the federation or NIPoPoWs, depending on the deployment of the smart contract. Subsequently, he needs to wait for a contestation period of $k$ blocks. Any party who wishes to dispute the proof can do so within this period by calling the \textsf{submit-contesting-proof} function. After the period has passed, the user can finalize the event by calling the \textsf{finalize-event} method.

We note that the contestation period can be omitted in the case of a federated setup, because if a proof has been valid once there is no way for anyone to dispute it.

Finally, the user can call the \textsf{claim} function with the event to receive his funds on the target blockchain. The \textsf{claim} function is responsible for checking that its caller's address is correctly encoded in the receiving address of the transaction described by the event by making use of $\BurnVerify$. If everything is correct, the amount of the burn transaction is released to the address of the caller in the form of an ERC-20 token.

In the interest of keeping this implementation generic we assume that the user receives a token in return for his burn. However, instead of minting a token, the target cryptocurrency could allow the burn verifier contract to mint native cryptocurrency for any user who successfully claims an event. This would allow the target cryptocurrency to be bootstrapped entirely though burning as desired.
