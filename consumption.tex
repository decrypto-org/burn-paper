\section{Consumption}

We now describe how a smart contract on the target blockchain can verify that a burn has taken place on the source blockchain. Note how this puts a constraint on the target blockchain to have smart contract capabilities. However there is no such constraint for the source blockchain. Such a mechanism allows a target cryptocurrency to bootstrap through burns on another source blockchain as outlined in Section~\ref{section:introduction}.

A user who wishes to acquire a target cryptocurrency first has to form a burn address which encodes her receiving address on the target blockchain by using it as a tag. The user then sends an amount of the source cryptocurrency to that address. She then proceeds to submit a proof of this burn to a smart contract on the target blockchain, where the burn is verified and the user is credited an equivalent amount of target cryptocurrency on her receiving address.

In accordance to the terminology laid out in~\cite{pow-sidechains}, we call this party the \emph{prover} and we call the smart contract the \emph{verifier}.

We abstract the functionalities regarding transactions on the source blockchain into a \emph{blockchain transaction protocol}.

\begin{definition}[Blockchain transaction protocol]\label{def:blockchain-tx}
  A \emph{blockchain transaction protocol} $\Pi_\zeta$ consists of two functions $\VerTxIncl$ and $\TxHasTransfer$.

  \begin{itemize}
    \item $\VerTxIncl(b, tx, \tau)$: Given block $b$, transaction $tx$ and a proof $\tau$, return $\true$ if $\tau$ is a valid proof for the fact that $tx \in b$.
    \item $\TxHasTransfer(tx, addr, amount)$: Given transaction $tx$, an address $addr$ and an amount, return $\true$ if $tx$ contains a value transfer of the specified amount towards the specified address.
  \end{itemize}
\end{definition}

More concretely, in Bitcoin, each block header contains a commitment to the set of transaction ids in the block in the form of a Merkle Tree root. Thus, for Bitcoin the proof $\tau$ for $\VerTxIncl$ is a Merkle Tree inclusion proof. Ethereum stores a similar commitment in its header, in the form of the root of a Merkle--Patricia Trie~\cite{wood2014ethereum}.

For a verifier to be convinced that a burn has taken place on a source blockchain, they need to ensure that the burn is contained in a transaction which belongs to the source blockchain. Specifically, the following data need to be supplied to the smart contract:

\begin{itemize}
  \item \textsf{tx}: The transaction which contains the burn on the source blockchain.
  \item \textsf{b}: The block where the aforementioned transaction is contained.
  \item $\tau$: An inclusion proof showing that $\mathsf{tx} \in \mathsf{b}$ such that $\VerTxIncl(\textsf{b}, \textsf{tx}, \tau) = \true$.
  \item \textsf{blockConnection}: A proof that \textsf{b} is contained in the best (i.e., most proof-of-work) source blockchain.
\end{itemize}

Putting these together, the final proof is the tuple $\beta = \sf(tx, \tau, b, blockConnection)$.

Transferring value from a source to a target blockchain has already been a subject of research. A mechanism for the so-called 1-way pegs is described in~\cite{pow-sidechains}. We adapt a modified version of this scheme for our purposes, to achieve our own 1-way peg by making use of Proof-of-Burn. A 1-way peg is established when there is the ability to transfer an amount of source cryptocurrency to a target blockchain in a trustless manner, as we wish to do. Generally, the prover wishes to convince the verifier that an event has taken place on the source blockchain. We define an event as a simple value transfer described by (a) a transaction id \textsf{txid}, (b) a receiving address \textsf{receiver} and (c) an amount \textsf{amount}. Thus our event takes the form of the tuple $e = (\textsf{txid}, \textsf{receivingAddress}, \textsf{amount})$. We remark that simple value transfers are supported by all popular cryptocurrencies, allowing a verifier to process burns from a wide range of source blockchains. We also remark that for now this event type does not yet distinguish between burn and non-burn addresses.

This verifier contract is responsible for receiving, verifying and then storing events on the other blockchain. It relies on a function $\mathsf{verify}^{e,\mathcal{G}}(\mathcal{P})$, where $\mathcal{P}$ is a set of proofs for the event, which returns $\true$ if and only if the event is valid based on the set of proofs provided. The functions of the protocol, in the order in which they should be called are as follows:

\begin{itemize}
  \item $\textsf{submit-event-proof}(\pi, e)$: A prover calls this function while putting down a collateral $z$ with an event $e$ and a proof of it $\pi$. The function determines if the proof provided is valid by making use of the \textsf{verify} method. If the proof is valid, a contestation period of $k$ blocks begins where other provers may submit a contesting proof.
  \item $\textsf{submit-contesting-proof}(\pi^*, e)$: A prover calls this function if they have a contesting proof for the proof provided previously for event $e$. If through the use of \textsf{verify} it is discovered that the original prover was dishonest, her collateral gets transferred to the caller of this function and the event is discarded.
  \item $\textsf{finalize-event}(e)$: A prover calls this function when the contestation period has passed for their event $e$. If there has been no successful contesting prover in the meantime, their event is saved in the set of finalized events on the smart contract.
  \item $\textsf{event-exists}(e)$: A user of the contract calls this function to determine whether an event $e$ has been proven and finalized.
\end{itemize}

\import{./}{algorithms/alg.verify-tx.tex}

Before looking at how the verification works for the whole proof $\beta$ we focus on the part of the proof pertaining to the transaction, specifically $\alpha = \sf(tx, \tau, b)$. Verifying this part of the proof for some event $e$ is straightforward by making use of the blockchain transaction protocol in Definition~\ref{def:blockchain-tx}. We ensure that the transaction \textsf{tx} indeed contains the value transfer claimed in the provided event $e$, and that the transaction is really contained in the block provided. The function, \textsf{verify-tx}, can be seen in detail in Algorithm~\ref{alg.verify-tx}.

Now that the issue of verifying the transaction is covered, we move our attention to the issue of verifying that the provided block \textsf{b} really belongs to the best source blockchain. For this we make use of NIPoPoWs. The block connection proof is a NIPoPoW for the block which includes the burn transaction.

\import{./}{algorithms/alg.verify-event-nipopow.tex}

The NIPoPoW event verification function, illustrated in Algorithm~\ref{alg.verify-event-nipopow}, first verifies the transaction part of the proof by making use of \textsf{verify-tx} and subsequently delegates to the NIPoPoW verification function \textsf{verify-infix}. In case of a contesting proof, the parameter $\mathcal{P}$ passed to the verification function contains both the original and the contesting proofs.

\subsection{Bootstraping Mechanism}
\import{./}{algorithms/alg.burn-verifier.tex}

Being able to verify events, we can finally make use of verified events in order to grant target cryptocurrency to users who burn source cryptocurrency. After burning on the source blockchain, the user needs to complete the event submission through \textsf{submit-event-proof} as described earlier. After the event is verified successfully and finalized, the user calls the \textsf{claim} function with the forementioned event. This function ensures that the event provided is finalized and has not been claimed before (i.e. noone has been granted target cryptocurrency for this specific event in the past). Then, after verifying through $\BurnVerify$ that the receiving address of the event is a burn address where the tag is the function caller's address, it releases the amount of coins burned in the form of an ERC-20 token. We present a contract with this capability in Algorithm~\ref{alg.burn-verifier} which we call the \textsf{burn-verifier}.

In the interest of keeping this implementation generic we assume that the user receives a token in return for his burn. However, instead of minting a token, the target cryptocurrency could allow the burn verifier contract to mint native cryptocurrency for any user who successfully claims an event. This would allow the target cryptocurrency to be bootstrapped entirely though burning as desired.

\subsection{Verifying Block Connection with a Federation}
We now introduce a second way for proving and verifying the block connection.

\import{./}{algorithms/alg.verify-event-federation.tex}

Let us assume that the smart contract holds in its state the continuously updated set of all valid blocks on the best source blockchain, in the form of a Merkle Tree root $\mathcal{M}$. Then, by verifying a Merkle Tree inclusion proof \textsf{blockConnection} for $\textsf{b} \in \mathcal{M}$ a verifier can be certain that the block provided is indeed part of the best source blockchain. Combined with verifying the transaction this completes our $\textsf{verify}_\mathcal{M}^e$ function, shown in Algorithm~\ref{alg.verify-event-federation}.

We now address the final issue of maintaining an up-to-date set of blocks in the form of $\mathcal{M}$. We propose a federation mechanism of source blockchain full nodes that monitor the source chain and vote for the new set of source chain blocks, if and when it changes. A majority of votes is necessary for $\mathcal{M}$ to be updated on the target blockchain. In this manner, the federation federation acts as a bridge from the source to the target blockchain. The security of our scheme relies on the assumption that the federation majority is honest.

We propose encoding the honestly adopted chain by using Merkle Mountain Ranges (MMRs)~\cite{flyclient}. Specifically, to generate a checkpoint we take all the chain's block ids in sequence and use them as leaves in a Merkle Mountain Range. We then use the root of that MMR as our encoding. Our rationale for using MMRs instead of other kinds of Merkle Trees is that we expect the most frequent modifications to the tree to be appends (when the source chain is extended by one block), which is a very efficient operation to perform on an existing MMR.

An interesting observation is that, because the federation majority is trusted on the target blockchain, we could avoid hashing block headers in order to verify block connection. Instead of storing the block id of each block in the MMR, we could store the transaction merkle root of each block, and again use the root of the MMR as the checkpoint. The verifier on the smart contract side would then verify that the \textsf{txIDMerkleRoot} provided exists in the MMR using the \textsf{blockConnection}.

Finally we remark that with this setup there is no need for a contestation period. If a checkpoint is voted by the federation majority and a valid block connection proof based on that checkpoint is provided, it cannot be disputed. This entails that \textsf{submit-contesting-proof} is not necessary and \textsf{submit-event-proof} can directly call \textsf{finalize-event} once the proof provided has been verified.
