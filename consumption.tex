\section{Consumption}

Over the last 5 years there has been an explosion of innovation through new cryptocurrencies. Unfortunately, it is very hard for a new cryptocurrency to gain traction. Without traction, no market depth ensues and a cryptocurrency has difficulty getting listed in any exchange. But without being listed in any exchange, a cryptocurrency cannot gain sufficient traction.

This chicken-and-egg situation presents the need for a solution that circumvents exchanges and allows users to acquire the cryptocurrency in a usable manner, for it to gain traction. We propose utilizing proof-of-burn to allow users to obtain capital on a new cryptocurrency, automatically and without trusted third parties, by burning a legacy cryptocurrency. We call the former the \emph{source cryptocurrency}, and its blockchain the \emph{source blockchain}. We call the latter the \emph{target cryptocurrency} and its corresponding blockchain the \emph{target blockchain}. The target blockchain may support burning from multiple source blockchains.

\noindent
\textbf{Workflow.}
A user who wishes to acquire a target cryptocurrency first forms a burn address valid in the source blockchain which encodes her receiving address on the target blockchain by using it as a tag. She then sends an amount of the source cryptocurrency to that address. She submits a proof of this burn to a smart contract on the target blockchain, where it is verified and she is credited an equivalent amount of target cryptocurrency on her receiving address. Proof-of-burn verification happens in either a centralized manner which is lighter on computation, or in a decentralized manner using NIPoPoWs.

Target blockchain miners need not be connected to every other source blockchain network. We call this property \emph{miner-isolation} and we propose methods to achieve it.

We now describe how a smart contract on the target blockchain can verify that a burn has taken place on the source blockchain. Note how this puts a constraint on the target blockchain to have smart contract capabilities. However there is no such constraint for the source blockchain.

In accordance to the terminology laid out in~\cite{pow-sidechains}, we call the user the \emph{prover} and the smart contract the \emph{verifier}.

The prover wishes to convince the verifier that an event has taken place on the source blockchain. We define an event as a simple value transfer described by (a) a transaction id \textsf{txid}, (b) a receiving address \textsf{addr} and (c) an amount \textsf{amount}. We remark that simple value transfers are supported by all popular cryptocurrencies, allowing a verifier to process burns from a wide range of source blockchains. We also remark that for now this event type does not yet distinguish between burn and non-burn addresses.

For a verifier to be convinced that an event has taken place on a source blockchain, they need to ensure that its transaction is contained the best source chain. Specifically, the following data need to be supplied to the smart contract:

\begin{itemize}
  \item \textsf{tx}: The transaction which contains the burn on the source blockchain.
  \item \textsf{b}: The block header for the block which contains the aforementioned transaction.
  \item $\tau$: An inclusion proof showing that $\mathsf{tx} \in \mathsf{b}$.
  \item \textsf{blockConnection}: A proof that \textsf{b} is contained in the best (i.e., most proof-of-work) source blockchain.
\end{itemize}

Putting these together, the final proof is the tuple $\beta = \sf(tx, \tau, b, block\-Connection)$.

We assume that the source blockchain provides a function \verifytx$(\textsf{addr}, \textsf{amount}, b, \textsf{tx}, \tau)$ which can be written in the smart contract language of the target blockchain and verifies the validity of a source blockchain transaction. It takes a source blockchain address \textsf{addr}, an amount of source cryptocurrency \textsf{amount}, a block $b$, a transaction \textsf{tx} and a proof $\tau$ for the inclusion of \textsf{tx} in $b$. It returns $\true$ if \textsf{tx} contains a transfer of \textsf{amount} to \textsf{addr} and the proof $\tau$ is valid for $b$.

The proof $\tau$ is usually a Merkle Tree inclusion proof. More concretely, in Bitcoin, each block header contains a commitment to the set of transaction ids in the block in the form of a Merkle Tree root. Ethereum stores a similar commitment in its header, in the form of the root of a Merkle--Patricia Trie~\cite{wood2014ethereum}.

For verifying that a provided block \textsf{b} really belongs to the best source blockchain, we assume the existence of a function $\textsf{is-in-best-chain}(b)$.

\noindent
\textbf{Bootstraping mechanism.}
Being able to verify events, we can grant target cryptocurrency to users who burn source cryptocurrency. After burning on the source blockchain, the user calls the \textsf{claim} function with the aforementioned event. This function ensures that the event provided is valid and has not been claimed before (i.e. no one has been granted target cryptocurrency for this specific event in the past), that it actually corresponds to the transaction $\tx$ provided and that the block $b$ provided actually belongs to the best source chain and contains $\tx$. Then, after verifying through $\BurnVerify$ that the receiving address of the event is a burn address where the tag is the function caller's address, it releases the amount of coins burned in the form of an ERC-20 token. We present a contract with this capability in Algorithm~\ref{alg.burn-verifier} which we call the \textsf{burn-verifier}.

\import{./}{algorithms/alg.burn-verifier.tex}

In the interest of keeping this implementation generic we assume that the user receives a token in return for his burn. However, instead of minting a token, the target cryptocurrency could allow the burn verifier contract to mint native cryptocurrency for any user who successfully claims an event. This would allow the target cryptocurrency to be bootstrapped entirely though burning as desired.

\noindent
\textbf{Verifying block connection.}
We now shift our attention to the problem of verifying a block belongs in the best source chain. We provide multiple ways of implementing the aforementioned \textsf{is-in-best-chain} method.

\noindent
\textbf{Direct observation.}
Miners connect to the source blockchain network and have access to the best source chain. A miner can thus evaluate if a block is included in that chain. This mechanism does not provide miner-isolation. It is adopted by Counterparty.

\noindent
\textbf{NIPoPoWs.}
Verifying block connection can be achieved through NIPoPoWs, as in~\cite{pow-sidechains}.
We remark that with this setup a block connection proof may be considered valid provisionally, but there needs to be a period in which the proof can be disputed for the smart contract to be certain for the validity of the proof. Specifically, when a user performs a claim, they have to put down some collateral. If they have provided a valid NIPoPoW a contestation period begins. Within that period a challenger can dispute the provided proof which would turn the result of \textsf{is-in-best-chain} to false, abort the claim and grant the challenger the user's collateral. If the contestation period ends with the proof undisputed then \textsf{is-in-best-chain} evaluates to true, the collateral gets returned to the user and the claim is performed successfully.

\noindent
\textbf{Federation.}
A simpler approach is to allow a federation of nodes monitoring the source chain to vote for the blocks that are included in the best source chain.

\import{./}{algorithms/alg.is-in-best-chain-federation.tex}

Let us assume that the smart contract holds in its state the continuously updated set of all valid blocks on the best source blockchain, in the form of a Merkle Tree root $\mathcal{M}$. Then, by verifying a Merkle Tree inclusion proof \textsf{blockConnection} for $\textsf{b} \in \mathcal{M}$ a verifier can be certain that the block provided is indeed part of the best source blockchain. This completes our {\sf is-in-best-chain}$_\mathcal{M}$ function, shown in Algorithm~\ref{alg.is-in-best-chain-federation}.

We now address the issue of maintaining an up-to-date set of blocks in the form of $\mathcal{M}$. We propose a federation mechanism of source blockchain full nodes that monitor the source chain and vote for the new set of source chain blocks, if and when it changes. A majority of votes is necessary for $\mathcal{M}$ to be updated on the target blockchain. In this manner, the federation acts as a bridge from the source to the target blockchain. The security of our scheme relies on the assumption that the federation majority is honest.

We propose encoding the honestly adopted chain by using Merkle Mountain Ranges (MMRs)~\cite{flyclient}. Specifically, to generate a checkpoint we take all the chain's block ids in sequence and use them as leaves in a Merkle Mountain Range. We then use the root of that MMR as our encoding. Our rationale for using MMRs instead of other kinds of Merkle Trees is that we expect the most frequent modifications to the tree to be appends (when the source chain is extended by one block), which is a very efficient operation to perform on an existing MMR.
