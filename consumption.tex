\section{Consumption}

We now describe how a smart contract on the target blockchain can verify that a burn has taken place on the source blockchain. Such a mechanism allows a target cryptocurrency to bootstrap through burns on another source blockchain as outlined in Section~\ref{section:introduction}. Specifically, a user is able to burn some coins on the source blockchain while encoding her receiving target blockchain address in the burn tag. After relaying this information to the smart contract the contract releases to the address in the tag an equivalent amount of target cryptocurrency.

In order to accomplish this, it is necessary for some party to relay the necessary information from the source to the target blockchain. In accordance to the terminology laid out in the Proof-of-Work Sidechains paper~\cite{pow-sidechains}, we call this party the \emph{prover} and we call the smart contract the \emph{verifier}.

\begin{definition}[Source chain protocol]
  \begin{itemize}
    \item $\VerTxIncl(b, tx, \tau)$: Given block $b$, transaction $tx$ and a proof $\tau$, return $\true$ if and only if $\tau$ is a valid proof for the fact that $tx \in b$.
    \item $\TxHasTransfer(tx, addr, amount)$: Given transaction $tx$, an address $addr$ and an amount, return $\true$ if and only if $tx$ contains a value transfer of the specified amount towards the specified address.
  \end{itemize}
\end{definition}

\begin{definition}[Merkle Tree protocol]
  A \emph{merkle tree} protocol $\mathcal{MT}$ consists of two functions $\mathcal{MT}_t(x_1, \dots, x_t)$ and $\VerMT_t(root, x, \pi)$ which work as follows:

  \begin{itemize}
    \item $\mathcal{MT}_t(x_1, \dots, x_t)$: Given elements $x_1, \dots, x_t$, return the root of the Merkle Tree with exactly $t$ leaves, where for each $1 \le i \le t$, the $i$-th leaf corresponds to $x_i$.

    \item $\VerMT(root, x, \pi)$: Given a Merkle Tree root, an element $x$ and an inclusion proof $\pi$, return $\sf{true}$ if and only if $\pi$ is a valid proof for the fact that $x$ is contained in the tree rooted at $root$.
  \end{itemize}
\end{definition}

For a verifier to be convinced that a burn has taken place on a source blockchain, they need to ensure that the burn is contained in a transaction which belongs to the source blockchain. Specifically, the following data needs to be supplied to the smart contract:

\begin{itemize}
  \item \textsf{tx}: The transaction which contains the burn on the source blockchain.
  \item \textsf{blk}: The block where the aforementioned transaction is contained.
  \item \textsf{txInclusion}: An inclusion proof showing that $\mathsf{tx} \in \mathsf{blk}$.
  \item \textsf{blockConnection}: A proof that \textsf{blk} is contained in the best source blockchain.
\end{itemize}

Putting these together, the final proof is the quartet $\beta = \sf(tx, txInclusion, blk, blockConnection)$.

\subsection{Proof-of-Work Sidechains}
Transferring value from a source to a target blockchain has already been a subject of research. A mechanism for 2-way pegs is described in Proof-of-Work Sidechains~\cite{pow-sidechains}. A 2-way peg is established when there is the the ability to transfer an amount of source cryptocurrency to a target blockchain and back in a trustless manner. The 2-way peg mechanism works roughly as a composition of two 1-way pegs. For our purposes we will focus on the mechanism which facilitates the one-way transfer. The prover is a full node on the source blockchain and the verifier is a smart contract on the target blockchain. The prover wishes to convince the verifier that an event has taken place on the source blockchain. In that work, an event describes a Solidity event emitted by a smart contract on some chain. It is described as a triplet $e = (chain, contract, aux)$, where $chain$ is an identifier for the chain, $contract$ refers to the address of the contract and $aux$ contains the parameters of the event emitted.

The contract \textsf{crosschain} is defined, which is initialized with the genesis block of the other blockchain $\mathcal{G}$. This contract is responsible for receiving, verifying and then storing events events on the other blockchain. It relies on a $\mathsf{verify}^{e,\mathcal{G}}(\mathcal{P})$, where $\mathcal{P}$ is a set of proofs for the event, which returns $\true$ if and only if the event is valid based on the set of proofs provided.

\begin{itemize}
  \item $\textsf{submit-event-proof}(\pi, e)$: A prover calls this function while putting down a collateral $z$ with an event $e$ and a proof of it $\pi$. The function determines if the proof provided is valid by making use of the \textsf{verify} method. If the proof is valid, a contestation period of $k$ blocks begins where other provers may submit a contesting proof.
  \item $\textsf{submit-contesting-proof}(\pi^*, e)$: A prover calls this function if they have a contesting proof for the proof provided previously for event $e$. If through the use of \textsf{verify} it is discovered that the original prover was dishonest her collateral gets transferred to the caller of this function and the event discarded.
  \item $\textsf{finalize-event}(e)$: A prover calls this function when the contestation period has passed for their event $e$. If there has been no successful contesting prover in the meantime, their event is saved in the set of finalized events on the smart contract.
  \item $\textsf{event-exists}(e)$: A user of the contract calls this function to determine whether an event $e$ has been proven and finalized.
\end{itemize}

\subsection{Transaction Inclusion Proof}

For simplicity we abbreviate the transaction inclusion part of the complete proof as $\alpha = \sf(tx, txInclusion, blk)$.

\import{./}{algorithms/alg.verify-tx.tex}

The transaction inclusion proof is defined by both Bitcoin and Ethereum. In Bitcoin, each block header contains a commitment to the set of transaction ids in the block in the form of a Merkle Tree root. Thus, for Bitcoin our transaction inclusion proof is of the form $\mathsf{txInclusion} = (\mathsf{txIDMerkleRoot}, \mathsf{txIDMerkleProof})$. The shape of the proof is as follows: $\mathsf{txIDMerkleProof} = ([x_0, x_1, \dots], \mathsf{txIndex}, \mathsf{txCount})$.

Ethereum stores a similar commitment in its header, in the form of the root of a Merkle-Patricia Trie~\cite{wood2014ethereum}. This trie contains the transactions of the block, using the transaction id of each transaction as a key to determine the path to follow starting from the root in order to arrive at that transaction. Similar to regular Merkle trees, Merkle-Patricia tries allow for leaf inclusion proofs.

The verification algorithm for $\alpha$ is presented in Algorithm~\ref{alg.verify-tx}. At the heart of the verification is the function $\TxHasTransfer$, which takes a transaction, an address and an amount and determines if a value transfer of that exact amount to the address provided has occurred inside the transaction provided. For Bitcoin, this function locates a P2PKH output with the exact amount and receiving address. For Ethereum, the function ensures that the transaction comprises a fund transfer (i.e. the \textsf{data} field is empty), to the receiving address provided and with the exact amount. If this check passes and the transaction inclusion proofs are valid, \textsf{verify-tx} function accepts the proof $\alpha$ for the specified event $e$.

\subsection{Block Connection Proof}

A federation of $m$ nodes is picked. A federation node is responsible for running the source blockchain software and knowing at every moment the honestly adopted source blockchain. More importantly, it is responsible for transmitting this information to the target blockchain. In order to do this, we define a smart contract on the target blockchain where federation nodes are allowed to submit such information. We call this contract the \textsf{TagRepository}. A federation node encodes the honestly adopted chain into a tag and submits this tag to the \textsf{TagRepository}. Once a majority of votes is achieved, the tag is considered valid for use.

We propose encoding the honestly adopted chain by using a Merkle Mountain Ranges (MMRs)~\cite{flyclient}. Specifically, to generate a tag we take all the chain's block ids in sequence and use them as leaves in a Merkle Mountain Range. We then use the root of that MMR as our encoding.

Knowing this, it is now possible to define \textsf{blockConnection}. This component is an MMR proof for the fact that that $id(\mathsf{blk}) \in \text{MMR}$ in the form of $\mathsf{blockConnection} = [(x_0, s_0), (x_1, s_1), \dots]$, where $s_i \in \sf\{Left, Right\}$.

An interesting observation is that, because the federation majority is trusted on the target blockchain, we could avoid doing the block header hashing and verification in order to verify block connection. Instead of storing the block id of each block in the MMR, we could store the transaction merkle root of each block, and again use the root of the MMR as the tag. The verifier on the smart contract side would then verify that the \textsf{txIDMerkleRoot} provided exists in the MMR using the \textsf{blockConnection}.

\import{./}{algorithms/alg.verify-event-federation.tex}

\subsection{Decentralized Block Connection}
We introduce a second way for proving and verifying the block connection which does not require a trusted federation. This is possible by making use of NIPoPoWs. The way the proving process works differs quite a bit from the federation, because in the federation there is a trusted source of truth. If a tag is voted by the federation majority, then it is forever true. But if this the verifier does not have this information, then it has to rely on the prover to get it. We assume a model where there exist two provers, one honest and one malicious. The block connection proof can be an NIPoPoW infix proof for the block which includes the burn transaction. Specifically, $\mathsf{blockConnection} = \pi\chi$.

\import{./}{algorithms/alg.verify-event-nipopow.tex}

However, this alone is not enough to persuade a verifier. It is possible that the prover is malicious and this proof is constructed for a non-honestly adopted chain (e.g. a temporary adversarial fork). In order for the verifier to be certain, it needs to allow for a honest prover to claim a better proof for a longer chain.

\subsection{Smart Contract Implementation}
\import{./}{algorithms/alg.burn-verifier.tex}

We present a smart contract in Algorithm~\ref{alg.burn-verifier} which we call the \textsf{burn-verifier}. The \textsf{burn-verifier} verifies burn events from the source chain. The contract extends the \textsf{crosschain} contract from \cite{pow-sidechains}. The \textsf{crosschain} contract is responsible for registering events on the source blockchain and verifying them. For our application, we parameterise \textsf{crosschain} with a \textsf{verify} function. The function presented in Algorithm~\ref{alg.verify-event-federation} can be used in a federated setup, and the function presented in Algorithm~\ref{alg.verify-event-nipopow} can be used in a decentralized setup.

The workflow is as follows. Once the user has created a burn transaction on the source blockchain, he submits the event along with a proof to the \textsf{submit-event-proof} function. The proof can be either using the MMR approved by the federation or NIPoPoWs, depending on the deployment of the smart contract. Subsequently, he needs to wait for a contestation period of $k$ blocks. Any party who wishes to dispute the proof can do so within this period by calling the \textsf{submit-contesting-proof} function. After the period has passed, the user can finalize the event by calling the \textsf{finalize-event} method.

We note that the contestation period can be omitted in the case of a federated setup, because if a proof has been valid once there is no way for anyone to dispute it.

Finally, the user can call the \textsf{claim} function with the event to receive his funds on the target blockchain. The \textsf{claim} function is responsible for checking that its caller's address is correctly encoded in the receiving address of the transaction described by the event by making use of $\BurnVerify$. If everything is correct, the amount of the burn transaction is released to the address of the caller in the form of an ERC-20 token.

In the interest of keeping this implementation generic we assume that the user receives a token in return for his burn. However, instead of minting a token, the target cryptocurrency could allow the burn verifier contract to mint native cryptocurrency for any user who successfully claims an event. This would allow the target cryptocurrency to be bootstrapped entirely though burning as desired.
