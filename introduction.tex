\section{Introduction}\label{section:introduction}

Over the last 5 years there has been an explosion of innovation through new cryptocurrencies. Unfortunately, it is very hard for a new cryptocurrency to gain traction. Without traction, and the market depth it ensues, a cryptocurrency will have difficulty getting listed in any exchange. But without being listed in any exchange a cryptocurrency cannot gain sufficient traction. The cryptocurrency can only be sold over-the-counter (OTC) by its miners or stakeholders, but the market for OTC trading and especially for an unknown cryptocurrency is traditionally very limited.

This chicken-and-egg situation presents the need for a solution that circumvents exchanges and allows users to acquire the cryptocurrency in a usable manner, in order for it to gain traction. We recommend utilizing proof-of-burn in order to can allow users to obtain capital on a new cryptocurrency, automatically and without trusted third parties, by burning a legacy proof-of-work cryptocurrency.

We wish to allow users to exchange a proof-of-work based cryptocurrency for a new cryptocurrency. We call the former the \emph{source cryptocurrency}, and the blockchain this cryptocurrency is based on the \emph{source blockchain}. We call the latter the \emph{target cryptocurrency} and its corresponding blockchain the \emph{target blockchain}. The target blockchain may support burning from multiple source blockchains.

\noindent
\textbf{Workflow.}
A user who wishes to acquire a target cryptocurrency first has to form a specially crafted address called the \emph{burn address}, which encodes among other things his receiving address on the target blockchain. The user then sends an amount of the source cryptocurrency to that address, essentially burning this amount in the source blockchain. He then proceeds to submit a proof of this burn on the target blockchain, where the burn is verified and the user is credited an equivalent amount of target cryptocurrency on his receiving address. The equivalent amount can be determined based to the macroeconomic model of the target cryptocurrency and is beyond the scope of this work. The verification of the proof of the burn can happen in either a centralized manner which is lighter on computation but requires a federation, or in a decentralized manner using Non-Interactive Proofs of Proof-of-Work (NIPoPoWs).

\noindent
\textbf{Properties.}
Like the rest of the system, proof-of-burn for money creation must be decentralized, i.e., there cannot be any ``committees'' or individuals verifying that proof-of-burn transactions took place and vouching for them. Additionally, target blockchain miners must remain connected only to the target blockchain network, hence we cannot mandate that every miner connects to every other network that we wish to burn funds from. In addition, the system should be uncensorable by source blockchain miners in case any of them decide that they do not agree with it. Finally the system should be easy to use, meaning that a user should be able to complete this procedure by using his existing wallet for the source cryptocurrency. To summarise, these are the properties that we desire such a system to satisfy:

\begin{itemize}
    \item \textbf{Unspendability.} No one should be able to spend the amount burned on the source blockchain.
    \item \textbf{Binding.} The burn must commit to details of the receiver on the target blockchain.
    \item \textbf{Uncensorability.} Miners who do not agree with this scheme on the source blockchain should not be able to censor burn transactions.
    \item \textbf{Usability.} The user should be able to create a burn transaction using his regular source cryptocurrency wallet.
    \item \textbf{Miner-isolation.} No miner on the target blockchain should be required to connect to the network of any of the source blockchains.
\end{itemize}

We propose a system which allows decentralized proof-of-burn-based bootstrapping and satisfies all the desired properties. To our knowledge, we are the first to do so.

In the heart of our construction, we make use of a primitive called
Non-Interactive Proofs of Proof-of-Work (NIPoPoWs), which allows the
construction of cross-chain certificates that can later be embedded in a remote
blockchain. The remote blockchains require to be \emph{interlinked}, a process
which can be performed using a velvet fork~\cite{velvet}. These interlinks have
already been deployed on some testnets by velvet fork~\cite{gtklocker} as well
as on some coins from genesis~\cite{ergo}.

\noindent
\textbf{Previous work.}
Proof-of-burn has been proposed as a mechanism of consensus akin to
proof-of-stake (cf. Slimcoin and Factom), as well as a mechanism for
establishing identity (OpenBazaar~\cite{zindros2016trust}) and notarization
(Carbon dating~\cite{clark2012commitcoin} and
OpenTimestamps~\cite{todd2016opentimestamps}). For bootstrapping
cryptocurrencies, proof-of-burn has been previously used in systems where direct
observation allowed for the system to give rise to the new tokens such as
Counterparty~\cite{counterparty}, a velvet fork of Bitcoin. The construction posed by Counterparty only satisfies two of the desired properties, namely unspendability and binding. It does not satisfy usability as the user needs to create a special type of transaction with an \textsf{OP\_RETURN} output. Because of this it also does not satisfy uncensorability, since this form of transaction can be easily detected by miners. Finally, it does not satisfy miner-isolation as users need to be connected to the Bitcoin network in order for the burn transactions to be verified.

NIPoPoWs were introduced in~\cite{nipopows}, improving upon previous
work~\cite{popow,highway}. Cross-chain applications using NIPoPoWs include
proof-of-work sidechains~\cite{pow-sidechains}. Comparable schemes have been
proposed for proof-of-stake systems~\cite{pos-sidechains}.

\noindent
\textbf{Our contributions.}
A summary of our contributions is as follows:
\begin{enumerate}[wide, labelwidth=!, labelindent=0pt, label=(\roman*)]
    \item \textbf{Primitive definition.} Our definitional contribution introduces Proof-of-Burn as a cryptographic primitive for the first time. We
    define it as a protocol which consists of two algorithms, a burn address \emph{generator} and a burn address \emph{verifier}. We put forth the foundational properties which make for secure burn protocols, namely \emph{unspendability}, \emph{binding}, and \emph{uncensorability}.
    \item \textbf{Novel construction.} We propose a novel and simple construction which is flexible and can be adapted for use in existing cryptocurrencies, as long as they use public key hashes for address generation. To our knowledge, all popular cryptocurrencies are
    compatible with our scheme. We prove our construction secure in the Random Oracle model.
    \item \textbf{Experimental results.} We provide a compehensively tested production grade implementation of our burn verifier in Ethereum
    written in Solidity, which we release as open source software. Our implementation can be used to consume proofs of burn of a source blockchain
    within a target blockchain. We provide experimental measurements for the cost of burn verification and find that, in current Ethereum prices,
    burn verification costs $\$0.31$ per transaction.
    This allows coins burned on one blockchain to be consumed on another for the purposes of, for example, ERC-20 tokens creation~\cite{erc20}.
\end{enumerate}

We propose a cryptocurrency proof-of-burn bootstrapping mechanism which is both
decentralized and miner-isolated. Our construction in principle allows burning
from any proof-of-work-based cryptocurrency, but in particular we highlight the
ability to burn from Bitcoin~\cite{bitcoin},
Bitcoin Cash, Litecoin~\cite{lee2011litecoin},
Ethereum~\cite{buterin2014next,wood2014ethereum}, Ethereum
Classic~\cite{classic2017ethereum}, Monero~\cite{van2013cryptonote},
ZCash~\cite{SP:BCGGMT14,hopwood2016zcash}.

\noindent
\textbf{Notation.} We use $\uniform(S)$ to denote the uniform distribution
obtained by sampling any item of the set $S$ with probability $\frac{1}{|S|}$.
We denote the support of a distribution $\mathcal{D}$ by $[\mathcal{D}]$.
We denote the empty string by $\epsilon$ and string concatenation by $\conc$.
