\section{Introduction}\label{section:introduction}
Proof-of-burn was invented in 2012 by Iain Stewart~\cite{stewart} as a mechanism for destroying cryptocurrency in an irrevocable and provable manner. It has since been used as a consensus mechanism similar to proof-of-stake (Slimcoin~\cite{slimcoin}), as a mechanism for establishing identity (OpenBazaar~\cite{zindros2016trust}), notarization (Carbon dating~\cite{clark2012commitcoin} and OpenTimestamps~\cite{todd2016opentimestamps}) and bootstrapping a new cryptocurrency (Counterparty~\cite{counterparty}).

While its adoption is undeniable, there has not been a formal treatment for proof-of-burn. This is the gap this work aims to fill.

\noindent
\textbf{Workflow.}
A user who wishes to burn her coins generates an address which we call a \emph{burn address} that encodes some metadata called the \emph{tag}. She then proceeds to send any amount of cryptocurrency to the burn address. After burning her cryptocurrency, she proves to any interested party that she irrevocably destroyed the cryptocurrency in question.

\noindent
\textbf{Properties.}
We define the following properties for a proof-of-burn protocol:
\begin{itemize}
    \item \textbf{Unspendability.} No one can spend the amount burned.
    \item \textbf{Binding.} The burn commits only to a single tag.
    \item \textbf{Uncensorability.} Miners who do not agree with this scheme cannot censor burn transactions.
    \item \textbf{Usability.} The user can create a burn transaction using her regular cryptocurrency wallet.
\end{itemize}

\noindent
\textbf{Our contributions.}
A summary of our contributions is as follows:
\begin{enumerate}[wide, labelwidth=!, labelindent=0pt, label=(\roman*)]
    \item \textbf{Primitive definition.} Our definitional contribution introduces proof-of-burn as a cryptographic primitive for the first time. We
    define it as a protocol which consists of two algorithms, a burn address \emph{generator} and a burn address \emph{verifier}. We put forth the foundational properties which make for secure burn protocols, namely \emph{unspendability}, \emph{binding}, and \emph{uncensorability}.
    \item \textbf{Novel construction.} We propose a novel and simple construction which is flexible and can be adapted for use in existing cryptocurrencies, as long as they use public key hashes for address generation. To our knowledge, all popular cryptocurrencies are
    compatible with our scheme. We prove our construction secure in the Random Oracle model.
    \item \textbf{Bootstrapping mechanism.} We propose a cryptocurrency proof-of-burn bootstrapping mechanism which does not require miners to connect to external blockchain networks and can be decentralized by making use of Non-Interactive Proofs of Proof-of-Work (NIPoPoWs)~\cite{nipopows}. Our mechanism in principle allows burning from any proof-of-work-based cryptocurrency.
    \item \textbf{Experimental results.} We provide a compehensively tested production-grade implementation of the bootstrapping mechanism in Ethereum
    written in Solidity, which we release as open source software. Our implementation can be used to consume proofs of burn of a source blockchain
    within a target blockchain. We provide experimental measurements for the cost of burn verification and find that, in current Ethereum prices,
    burn verification costs $\$0.31$ per transaction.
    This allows coins burned on one blockchain to be consumed on another for the purposes of, for example, ERC-20 tokens creation~\cite{erc20}.
\end{enumerate}

\noindent
\textbf{Related work.}
NIPoPoWs were introduced in~\cite{nipopows}, improving upon previous work~\cite{popow,highway}. Cross-chain applications using NIPoPoWs include proof-of-work sidechains~\cite{pow-sidechains}. Comparable schemes have been proposed for proof-of-stake systems~\cite{pos-sidechains}.


\noindent
\textbf{Notation.} We use $\uniform(S)$ to denote the uniform distribution
obtained by sampling any item of the set $S$ with probability $\frac{1}{|S|}$.
We denote the support of a distribution $\mathcal{D}$ by $[\mathcal{D}]$.
We denote the empty string by $\epsilon$ and string concatenation by $\conc$.
