\section{Defining Proof-of-Burn}

Let $\kappa$ be the security parameter.

\begin{definition}[Burn protocol]
  A \emph{burn} protocol $\Pi$ consists of two functions $\GenBurnAddress(1^\kappa, t)$ and $\BurnVerify(1^\kappa, t, \burnAddr)$ which work as follows:

  \begin{itemize}
    \item $\GenBurnAddress(1^\kappa, t)$: Given a tag $t$, generate a \emph{burn address}.

    \item $\BurnVerify(1^\kappa, t, \burnAddr)$: Given a tag $t$, return $\sf{true}$ if and only if $\burnAddr$ is a burn address and correctly encodes $t$.
  \end{itemize}
\end{definition}

Intuitively, the protocol works as follows. Alice first generates an address $\burnAddr$ to which she will send some cryptocurrency. The address encodes information contained in a tag $t$ and is generated through $\GenBurnAddress(1^\kappa, t)$. Alice then proceeds to send her cryptocurrency to the generated address. When the transaction is completed, she can provide the transaction and the tag to Bob for him to verify that she has irrecovably destroyed an amount of cryptocurrency while committing to the provided tag. Bob will verify that the receiving address of the transaction provided actually encodes the given tag, by making use of $\BurnVerify(1^\kappa, t, \burnAddr)$.

We require that the burn scheme is \emph{correct}.

\begin{definition}[Correctness]
  A burn protocol $\Pi$ is \emph{correct} if for all $t \in \{0,1\}^*$ and for all $\kappa \in \mathbb{N}$ it holds that
  $\BurnVerify(1^\kappa, t, \GenBurnAddress(1^\kappa, t)) = \true$.
\end{definition}

With foresight, we remark that the implementation of $\GenBurnAddress$ and $\BurnVerify$ will typically be deterministic, which alleviates the need for a probabilistic correctness definition.

Naturally, for $\GenBurnAddress$ to generate addresses that ``look'' valid but are unspendable according to the blockchain protocol requires that the burn protocol respects the format of the blockchain protocol. We abstract the functionalities of the blockchain protocol into a \emph{blockchain address protocol}:

\begin{definition}[Blockchain address protocol]
  A \emph{blockchain address protocol} $\Pi_\alpha$ consists of two functions $\sf{GenAddress}$ and $\sf{SpendVerify}$:

  \begin{itemize}
    \item $\sf{GenAddress}(1^\kappa)$: Returns a tuple $(\sf{pk}, \sf{sk})$, denoting the cryptocurrency address $\sf{pk}$ (a public key) used to receive money and its respective secret key $\sf{sk}$ which allows spending from that address.

    \item $\sf{SpendVerify}(m, \sigma, pk)$: Returns $\sf{true}$ if the transaction $m$ spending from receiving address $pk$ has been authorized by the signature $\sigma$ (by being signed by the respective private key).
  \end{itemize}
\end{definition}

We note that, while the blockchain address protocol is not part of the burn protocol, the \emph{security} properties of a burn protocol $\Pi$ will be defined with respect to a \emph{blockchain address protocol} $\Pi_\alpha$.

These two functionalities are typically implemented using a standard public-key signature scheme and are accompanied by a respective signing algorithm. The signing algorithm is irrelevant for our burn purposes, since burning entails the inability to spend. We intentionally leave the format of the transaction $m$ undefined. We remark here that the format of $m$ is cryptocurrency-specific. In both Bitcoin and Ethereum, $m$ corresponds to transaction data. When a new candidate transaction is received from the network, the blockchain node calls $\textsf{SpendVerify}$, passing the public key $pk$ which is spending money incoming to the new transaction $m$ together with a signature $\sigma$ which should be produced using the respective secret key and signs transaction $m$. In the case of Bitcoin's P2PKH, $pk$ and $\sigma$ can be extracted from the scriptSig data, while $m$ contains the new scriptPubKey~\cite{bitcoin-dev-guide}.

To state that the protocol generates addresses which cannot be spent from, we introduce a game-based security definition. The unspendability game $\spendattack$ is illustrated in Algorithm~\ref{alg.spend-game}.

\import{./}{algorithms/alg.spend-game.tex}

\begin{definition}[Unspendability]
  A burn protocol $\Pi$ is \emph{unspendable} with respect to a blockchain address protocol $\Pi_\alpha$ if
  for all probabilistic polynomial-time adversaries $\mathcal{A}$ there exists a negligible function $\negl$ such that
  $
    \Pr[\spendattack_{\mathcal{A}, \Pi}(\kappa) = \textsf{true}] \leq \negl
  $.
\end{definition}

\import{./}{algorithms/alg.bind-game.tex}

\begin{definition}[Binding]
  A burn protocol $\Pi$ is \emph{binding} if
  for all probabilistic polynomial-time adversaries $\mathcal{A}$ there is a
  negligible function $\negl$ such that
  $\Pr[\bindattack_{\mathcal{A},\Pi}(\kappa)] \leq \negl$.
\end{definition}

We note here that the correctness and binding properties of a burn protocol are irrespective of the blockchain address protocol it was designed for.

We are now ready to define what constitutes a \emph{secure proof-of-burn protocol}.

\begin{definition}[Security]
  Let $\Pi$ be a correct burn protocol correct. We say that $\Pi$ is \emph{secure} with respect to a blockchain address protocol $\Pi_\alpha$ if it is \emph{unspendable} and \emph{binding} with respect to $\Pi_\alpha$.
\end{definition}

The aforementioned properties form a good basis for a burn protocol. We observe that it may be possible to detect whether an address is a burn address. While this is desirable in certain circumstances, it allows miners to censor burn transactions. To mitigate this, we propose \emph{uncensorability}, a property which mandates that a burn address is indistinguishable from a regular address if its tag is not known. During the execution of protocols which satisfy this property, when the burn transaction appears on the network, only the user who performed the burn knows that it constitutes a burn transaction prior to revealing the tag. Naturally, as soon as the tag is revealed, \emph{correctness} mandates that the burn transaction becomes verifiable.

\begin{definition}[Uncensorability]
  A burn protocol $\Pi$ is \emph{uncensorable} if
  the distribution ensembles $\{A_\kappa \gets \GenAddress(1^\kappa)\}_\kappa$ and
  $\{B_\kappa \gets \GenBurnAddress(1^\kappa, \cdot)\}_\kappa$ are computationally indistinguishable.
\end{definition}
