\section{Defining Proof-of-Burn}

Let $\kappa$ be the security parameter.

\begin{definition}[Burn protocol]
  A \emph{burn} protocol $\Pi$ consists of two functions $\GenBurnAddress(1^\kappa, t)$ and $\BurnVerify(1^\kappa, t, \burnAddr)$ which work as follows:

  \begin{itemize}
    \item $\GenBurnAddress(1^\kappa, t)$: Given a tag $t$, generate a \emph{burn address}.

    \item $\BurnVerify(1^\kappa, t, \burnAddr)$: Given a tag $t$, return $\sf{true}$ if and only if $\burnAddr$ is a burn address and correctly encodes $t$.
  \end{itemize}
\end{definition}

Intuitively, the protocol works as follows. If Alice wishes to burn coins on a source blockchain in order to generate coins on a destination blockchain, Alice first generates a receiving address on the destination blockchain to which she will receive the coins in question. That receiving address, along with any potential metadata desired, is then encoded into the tag $t$. Alice then calls $\GenBurnAddress(1^\kappa, t)$ to generate a burn address $\burnAddr$, which is a valid address on the source blockchain. Alice can then send money to $\burnAddr$ on the source blockchain. That money is destroyed and unspendable. Alice can present the tag $t$ to Bob who wishes to verify that $\burnAddr$ really is a burn address. Bob calls $\BurnVerify(1^\kappa, t, \burnAddr)$ and ensures that it returns $\true$. When Bob sees Alice's transaction which spends money to $\burnAddr$ on the source blockchain, he knows that the money really is unspendable and was sent by Alice with the intention of receiving the corresponding amount to address $t$ on the destination blockchain.

Naturally, for $\GenBurnAddress$ to generate addresses that ``look'' valid but are unspendable according to the source blockchain protocol requires that the burn protocol respects the format of the source blockchain protocol. We abstract the functionalities of the source blockchain protocol into a \emph{blockchain address protocol}:

\begin{definition}[Blockchain address protocol]
  A \emph{blockchain address protocol} $\Pi_\alpha$ consists of two functions $\sf{GenAddress}$ and $\sf{SpendVerify}$:

  \begin{itemize}
    \item $\sf{GenAddress}(1^\kappa)$: Returns a tuple $(\sf{pk}, \sf{sk})$, denoting the cryptocurrency address $\sf{pk}$ (a public key) used to receive money and its respective secret key $\sf{sk}$ which allows spending from that address.

    \item $\sf{SpendVerify}(m, \sigma, pk)$: Returns $\sf{true}$ if the transaction $m$ spending from receiving address $pk$ has been authorized by the signature $\sigma$ (by being signed by the respective private key).
  \end{itemize}
\end{definition}

We note that, while the blockchain address protocol is not part of the burn protocol, the \emph{correctness} and \emph{security} properties of a burn protocol $\Pi$ will be defined with respect to a \emph{blockchain address protocol} $\Pi_\alpha$.

These two functionalities are typically implemented using a standard public-key signature scheme and are accompanied by a respective signing algorithm. The signing algorithm is irrelevant for our burn purposes, since burning entails the inability to spend. We intentionally leave the format of the transaction $m$ undefined. We remark here that the format of $m$ is cryptocurrency-specific. In both Bitcoin and Ethereum, $m$ corresponds to transaction data. When a new candidate transaction is received from the network, the blockchain node calls $\textsf{SpendVerify}$, passing the public key $pk$ who is spending money incoming to the new transaction $m$ together with a signature $\sigma$ which should be produced using the respective secret key and signs transaction $m$. In the case of Bitcoin's p2pkh, $pk$ and $\sigma$ can be extracted from the scriptSig data, while $m$ contains the new scriptPubKey.

We require that the burn scheme is \emph{correct}. That is, if a burn address is generated correctly it should verify.

\begin{definition}[Correctness]
  A burn protocol $\Pi$ is \emph{correct} with respect to a blockchain address protocol $\Pi_\alpha$ if for all $t$ and for all $\kappa$ it holds that
  $\BurnVerify(1^\kappa, t, \GenBurnAddress(1^\kappa, t)) = \textsf{true}$.
\end{definition}

With foresight, we remark that the implementation of $\GenBurnAddress$ and $\BurnVerify$ will be deterministic, which alleviates the need for a probabilistic correctness definition.

To state that the protocol generates addresses which cannot be spent from, we introduce a game-based security definition. The unspendability game \textsc{spend-attack} is illustrated in Algorithm~\ref{alg.spend-game}.

\import{./}{algorithms/alg.spend-game.tex}

\begin{definition}[Unspendability]
  A burn protocol $\Pi$ is \emph{unspendable} with respect to a blockchain address protocol $\Pi_\alpha$ if
  for all probabilistic polynomial-time adversaries $\mathcal{A}$ there exists a negligible function $negl$ such that:

  \[
    \Pr[\textsc{spend-attack}_{\mathcal{A},
    \Pi}(\kappa) = \textsf{true}] \leq \negl
  \]
\end{definition}

\import{./}{algorithms/alg.bind-game.tex}

\begin{definition}[Binding]
  A burn protocol $\Pi$ is \emph{binding} if
  for all probabilistic polynomial-time adversaries $\mathcal{A}$ it holds that:

  \[
    \Pr[\textsc{bind-attack}_{\mathcal{A},\Pi}(\kappa)] \leq \negl
  \]
\end{definition}

We note here that the binding property of a burn protocol is irrespective of the blockchain address protocol it was designed for.

We are now ready to define what constitutes a \emph{secure proof-of-burn protocol}.

\begin{definition}[Security]
  Let $\Pi$ be a burn protocol correct with respect to a blockchain address protocol $\Pi_\alpha$. We say that $\Pi$ is \emph{secure} if it is \emph{unspendable} and \emph{binding}.
\end{definition}

The aforementioned properties form a good basis for a burn protocol. However, it is possible that burns generated with a protocol that satisfies those properties are detectable. In that case, miners have the ability to censor burn transactions if they detect them. There may be economic incentives to do so, e.g. users may burn in order to fundraise for a project which may harm a miner's business. To mitigate this, a miner should not be able to discern between a regular and a burn transaction. Based on this, we define what constitutes an \emph{uncensorable proof-of-burn protocol}.

\begin{definition}[Uncensorability]
  A burn protocol $\Pi$ is \emph{uncensorable} if
  the distribution ensembles $\{A_\kappa \gets \GenAddress(1^\kappa)\}_\kappa$ and
  $\{B_\kappa \gets \GenBurnAddress(1^\kappa, \cdot)\}_\kappa$ are computationally indistinguishable.
\end{definition}
