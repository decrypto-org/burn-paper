\section{Defining Proof-of-Burn}

Let $\kappa$ be the security parameter. A proof-of-burn scheme is a protocol parameterized by the following functionalities offered by the source blockchain:

\begin{itemize}
  \item $\sf{GenAddress}(1^\kappa)$ which returns a tuple $(\sf{pk}, \sf{sk})$, denoting the cryptocurrency address $\sf{pk}$ (a public key) used to receive money and its respective secret key $\sf{sk}$ which allows spending from that address.

  \item $\sf{SpendVerify}(m, \sigma, pk)$ which returns $\sf{true}$ if and only if the transaction $m$ spending from receiving address $pk$ has been authorized by the signature $\sigma$ (by being signed by the respective private key).
\end{itemize}

Note that these two functionalities are typically implemented using a standard public-key signature scheme and are usually accompanied by a respective signing algorithm, which is irrelevant for our burn purposes, since burning entails the inability to spend. We intentionally leave the format of the transaction $m$ undefined. We remark here that the format of $m$ is cryptocurrency-specific. For example, it denotes an outpoint (a UTXO) of a transaction in the case of Bitcoin, while it denotes a full transaction in the case of Ethereum.

Then the functionality provided by a proof-of-burn scheme is:

\begin{itemize}
  \item $\mathsf{GenBurnAddress}(1^\kappa, t)$ which, given a tag $t$, generates a burn address in the form of the original blockchain.

  \item $\mathsf{BurnVerify}(1^\kappa, t, \mathsf{burnAddr})$ which returns $\sf{true}$ if and only if \textsf{burnAddr} encodes correctly the information of $t$.
\end{itemize}

We now describe the desirable properties of a proof-of-burn protocol. First, we state what makes a correct burn protocol.

\begin{definition}[Correctness]
  A burn protocol $\Pi$ is \emph{correct} if for all $t$ and for all $\kappa$ it holds that
  $\mathsf{BurnVerify}(1^\kappa, t, \mathsf{GenBurnAddress}(1^\kappa, t)) = \textsf{true}$.
\end{definition}

With foresight, we remark that the implementation of $\mathsf{GenBurnAddress}$ and $\mathsf{BurnVerify}$ will typically be deterministic, which alleviates the need for a probabilistic correctness definition.

To state that the protocol generates addresses which cannot be spent from, we introduce a game-based security definition. The unspendability game \textsc{spend-attack} is illustrated in Algorithm~\ref{alg.spend-game}.

\import{./}{algorithms/alg.spend-game.tex}

\begin{definition}[Unspendability]
  A burn protocol $\Pi$ is \emph{unspendable} if
  for all probabilistic polynomial-time adversaries $\mathcal{A}$
  it holds that

  \[
    \Pr[\textsc{spend-attack}_{\mathcal{A},
    \Pi}(\kappa) = \textsf{true}] \leq negl(\kappa)
  \]
\end{definition}

\import{./}{algorithms/alg.bind-game.tex}

\begin{definition}[Binding]
  A burn protocol $\Pi$ is \emph{binding} if
  for all probabilistic polynomial-time adversaries $\mathcal{A}$ it holds that:

  \[
    \Pr[\textsc{bind-attack}_{\mathcal{A},\Pi}(\kappa)] \leq negl(\kappa)
  \]
\end{definition}

\subsection{Uncensorable Proof-of-Burn}

\begin{definition}[Uncensorability]
  A burn protocol $\Pi$ is \emph{uncensorable} if
  the distribution ensembles $\{A_\kappa \gets \mathsf{GenAddress}(1^\kappa)\}_\kappa$ and
  $\{B_\kappa \gets \mathsf{GenBurnAddress}(1^\kappa, \cdot)\}_\kappa$ are computationally indistinguishable.
\end{definition}
