\section{Implementing Proof-of-Burn}

\import{./}{algorithms/alg.bitcoin.tex}

\subsection{The Proof-of-Burn}
Bitcoin and Bitcoin Cash employ mechanisms for burning money using a specialized
opcode called \textsf{OP\_RETURN}~\cite{bartoletti2017analysis}. Unfortunately,
creating an \text{OP\_RETURN} proof-of-burn transaction is complicated and not
user-friendly. However, it does benefit the Bitcoin network by allowing the UTXO
to be pruned.

As we wish our proof-of-burn mechanism to be user friendly, we propose a
different burn protocol. Our protocol appears in
Algorithm~\ref{alg.perturbation}.

\import{./}{algorithms/alg.perturbation.tex}

The algorithm works as follows Initially, the user generates a fresh dust key
$(pk, sk)$ to which they will receive their newly generated tokens. \todo{TODO:
What do these keys look like?} From the $pk$, the user derives a $64$-byte
\emph{key reference} $pkr = \textsf{SHA512}(pk)$. The key reference is then
treated as an uncompressed Bitcoin or Bitcoin Cash public key pair, i.e., its
first $32$-byte part is considered the $X$ coordinate and the second $32$-byte
part is considered the $Y$ coordinate of an elliptic curve. The key reference is
then prefixed with \texttt{0x04} and the result is hashed using
$\textsf{RIPEMD160}(\textsf{SHA256}(\cdot))$ as is usual for address generation.
This produces the \emph{key hash reference} $pkh$. The least significant bit of
$pkh$ is then flipped. This step is imperative to the security of the scheme to
ensure that the generated address is unspendable. This produces the $20$-byte
\emph{perturbated key hash reference} $pkh'$. The perturbated key hash reference
is then prefixed with \texttt{0x00} for the Bitcoin mainnet or with
\texttt{0x6f} for the Bitcoin testnet as usual. The checksum of the prefixed
perturbated key hash reference is then calculated as the last $4$ bytes of
$\textsf{SHA256}(\textsf{SHA256}(prefix || pkh'))$. These $4$ bytes are appended
to the prefixed perturbated key hash reference as a suffix, and the result is
\textsf{base58} encoded into a bitcoin address.

\begin{lemma}[Unspendability]
  Consider the construction of Algorithm~\ref{alg.perturbation} where
  $\textsf{RIPEMD160}(\cdot)$ is modelled as a Random Oracle, $\textsf{SHA256}$
  and $\textsf{SHA512}$  are collision-resistant. Then any address $\alpha$ for
  which a $pk$ is known such that $\alpha = \textsf{perturbe}(pk)$ is
  unspendable, the respective \emph{public key} under the Bitcoin address
  generation protocol cannot be found.
\end{lemma}
\begin{proof}(Sketch)
  From the fact that $pk$ is known.
  Suppose for contradiction that the public key was known.
  By the collision-resistance of $\textsf{SHA256}$, this gives a unique image of
  $k_2 = \textsf{SHA256}(\texttt{0x04} || pkr)$.
  The probability that, in a given execution, the Random Oracle will output two
  outputs $k_1, k_2$ with $k_1 \oplus k_2 = \texttt{0x01}$ is negligible.
\end{proof}

% TODO: avoid double spending
