\section{Implementing Proof-of-Burn}\label{section:construction}

\import{./}{algorithms/alg.bitcoin.tex}

\todo{explain the bitcoin protocol here ~gtklocker}

\subsection{The Proof-of-Burn}
Bitcoin and Bitcoin Cash employ mechanisms for burning money using a specialized
opcode called \textsf{OP\_RETURN}~\cite{bartoletti2017analysis}. Unfortunately,
creating an \text{OP\_RETURN} proof-of-burn transaction is complicated and not
user-friendly. However, it does benefit the Bitcoin network by allowing the UTXO
to be pruned.

As we wish our proof-of-burn mechanism to be user friendly, we propose a
different burn protocol. Our protocol appears in
Algorithm~\ref{alg.construction}.

\import{./}{algorithms/alg.construction.tex}

\begin{theorem}[Correctness]
  The above Proof-of-Burn protocol $\Pi$ is \emph{correct}.
\end{theorem}
\begin{proof}
  TODO
\end{proof}

\begin{lemma}[Unspendability]
  Consider the construction of Algorithm~\ref{alg.perturbation} where
  $\textsf{RIPEMD160}(\cdot)$ is modelled as a Random Oracle, $\textsf{SHA256}$
  and $\textsf{SHA512}$  are collision-resistant. Then any address $\alpha$ for
  which a $pk$ is known such that $\alpha = \textsf{perturbe}(pk)$ is
  unspendable, the respective \emph{public key} under the Bitcoin address
  generation protocol cannot be found.
\end{lemma}
\begin{proof}(Sketch)
  From the fact that $pk$ is known.
  Suppose for contradiction that the public key was known.
  By the collision-resistance of $\textsf{SHA256}$, this gives a unique image of
  $k_2 = \textsf{SHA256}(\texttt{0x04} || pkr)$.
  The probability that, in a given execution, the Random Oracle will output two
  outputs $k_1, k_2$ with $k_1 \xor k_2 = \texttt{0x01}$ is negligible.
\end{proof}

% TODO: avoid double spending
