\section{Construction}

\subsection{Definition}
A proof-of-burn scheme is a protocol parameterized by the following functionalities offered by the source blockchain:

\begin{itemize}
  \item $\sf{GenAddress}(1^\lambda)$ which returns a tuple $(\sf{pk}, \sf{sk})$, denoting the cryptocurrency address $\sf{pk}$ (a public key) used to receive money and its respective secret key $\sf{sk}$ which allows spending from that address.

  \item $\sf{SpendVerify}(m, \sigma, pk)$ which returns $\sf{true}$ if and only if the transaction $m$ spending from receiving address $pk$ has been authorized by the signature $\sigma$ (by being signed by the respective private key).
\end{itemize}

Note that these two functionalities are typically implemented using a standard public-key signature scheme and are usually accompanied by a respective signing algorithm, which is irrelevant for our burn purposes, since burning entails the inability to spend. We intentionally leave the format of the transaction $m$ undefined. We remark here that the format of $m$ is cryptocurrency-specific. For example, it denotes an outpoint (a UTXO) of a transaction in the case of Bitcoin, while it denotes a full transaction in the case of Ethereum.

Then the functionality provided by a proof-of-burn scheme is:

\begin{itemize}
  \item $\mathsf{GenBurnAddress}(1^\lambda, t)$ which, given a tag $t$, generates a burn address in the form of the original blockchain.

  \item $\mathsf{BurnVerify}(t, \mathsf{burnAddr})$ which returns $\sf{true}$ if and only if \textsf{burnAddr} encodes correctly the information of $t$.
\end{itemize}

We now describe the desirable properties of a proof-of-burn protocol. First, we state what makes a correct burn protocol.

\begin{definition}[Correctness]
  A burn protocol $\Pi$ is \emph{correct} if for all $t$ and for all $\lambda$ it holds that
  $\mathsf{BurnVerify}(t, \mathsf{GenBurnAddress}(1^\lambda, t)) = \textsf{true}$.
\end{definition}

With foresight, we remark that the implementation of $\mathsf{GenBurnAddress}$ and $\mathsf{BurnVerify}$ will typically be deterministic, which alleviates the need for a probabilistic correctness definition.

To state that the protocol generates addresses which cannot be spent from, we introduce a game-based security definition. The unspendability game \textsc{unsp-game} is illustrated in Algorithm~\ref{alg.unsp-game}.

\import{./}{algorithms/alg.spend-game.tex}

\begin{definition}[Unspendability]
  A burn protocol $\Pi$ is \emph{unspendable} if
  for all probabilistic polynomial-time adversaries $\mathcal{A}$
  it holds that

  \[
    \Pr[\textsc{spend-attack}_{\mathcal{A},
    \Pi}(\lambda) = \textsf{true}] \leq negl(\lambda)
  \]
\end{definition}

\import{./}{algorithms/alg.bind-game.tex}

\begin{definition}[Binding]
  A burn protocol $\Pi$ is \emph{binding} if
  for all probabilistic polynomial-time adversaries $\mathcal{A}$ it holds that:

  \[
    \Pr[\textsc{bind-attack}_{\mathcal{A},\Pi}(\lambda)] \leq negl(\lambda)
  \]
\end{definition}

\subsection{Uncensorable Proof-of-Burn}

\begin{definition}[Uncensorability]
  A burn protocol $\Pi$ is \emph{uncensorable} if
  the distribution ensembles $\{A_\lambda \gets \mathsf{GenAddress}(1^\lambda)\}_\lambda$ and
  $\{B_\lambda \gets \mathsf{GenBurnAddress}(1^\lambda, \cdot)\}_\lambda$ are computationally indistinguishable.
\end{definition}

\subsection{The Proof-of-Burn}
Bitcoin and Bitcoin Cash employ mechanisms for burning money using a specialized
opcode called \textsf{OP\_RETURN}~\cite{bartoletti2017analysis}. Unfortunately,
creating an \text{OP\_RETURN} proof-of-burn transaction is complicated and not
user-friendly. However, it does benefit the Bitcoin network by allowing the UTXO
to be pruned.

As we wish our proof-of-burn mechanism to be user friendly, we propose a
different burn protocol. Our protocol appears in
Algorithm~\ref{alg.perturbation}.

\import{./}{algorithms/alg.perturbation.tex}

The algorithm works as follows Initially, the user generates a fresh dust key
$(pk, sk)$ to which they will receive their newly generated tokens. \todo{TODO:
What do these keys look like?} From the $pk$, the user derives a $64$-byte
\emph{key reference} $pkr = \textsf{SHA512}(pk)$. The key reference is then
treated as an uncompressed Bitcoin or Bitcoin Cash public key pair, i.e., its
first $32$-byte part is considered the $X$ coordinate and the second $32$-byte
part is considered the $Y$ coordinate of an elliptic curve. The key reference is
then prefixed with \texttt{0x04} and the result is hashed using
$\textsf{RIPEMD160}(\textsf{SHA256}(\cdot))$ as is usual for address generation.
This produces the \emph{key hash reference} $pkh$. The least significant bit of
$pkh$ is then flipped. This step is imperative to the security of the scheme to
ensure that the generated address is unspendable. This produces the $20$-byte
\emph{perturbated key hash reference} $pkh'$. The perturbated key hash reference
is then prefixed with \texttt{0x00} for the Bitcoin mainnet or with
\texttt{0x6f} for the Bitcoin testnet as usual. The checksum of the prefixed
perturbated key hash reference is then calculated as the last $4$ bytes of
$\textsf{SHA256}(\textsf{SHA256}(prefix || pkh'))$. These $4$ bytes are appended
to the prefixed perturbated key hash reference as a suffix, and the result is
\textsf{base58} encoded into a bitcoin address.

\begin{lemma}[Unspendability]
  Consider the construction of Algorithm~\ref{alg.perturbation} where
  $\textsf{RIPEMD160}(\cdot)$ is modelled as a Random Oracle, $\textsf{SHA256}$
  and $\textsf{SHA512}$  are collision-resistant. Then any address $\alpha$ for
  which a $pk$ is known such that $\alpha = \textsf{perturbe}(pk)$ is
  unspendable, the respective \emph{public key} under the Bitcoin address
  generation protocol cannot be found.
\end{lemma}
\begin{proof}(Sketch)
  From the fact that $pk$ is known.
  Suppose for contradiction that the public key was known.
  By the collision-resistance of $\textsf{SHA256}$, this gives a unique image of
  $k_2 = \textsf{SHA256}(\texttt{0x04} || pkr)$.
  The probability that, in a given execution, the Random Oracle will output two
  outputs $k_1, k_2$ with $k_1 \oplus k_2 = \texttt{0x01}$ is negligible.
\end{proof}

% TODO: avoid double spending
