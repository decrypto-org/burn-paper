\section{Relaxing the Random Oracle model}\label{sec:standard}

The construction presented above works for P2PKH and achieves its unspendability, binding, and uncensorability in the Random Oracle model. In this section, we discuss alternative constructions which work without requiring the Random Oracle model.

The simplest blockchain address protocol is the Pay to Public Key (P2PK) which, in contrast to P2PKH does not hash the public key to generate an address. Instead, the address is literally the public key and spending verification simply checks the validity of a signature. This protocol is illustrated in Algorithm~\ref{alg.p2pk}.

\import{./}{algorithms/alg.p2pk.tex}

Without the Random Oracle model, our construction must be particular to the signature algorithm used to ensure uncensorability, as our addresses must look similar to public keys generated by the scheme. We describe a burn scheme which can work for the (EC)DSA signature scheme. Our scheme is provably correct, binding and uncensorable in the Common Random String model, assuming the DLOG problem is hard and a collision resistant hash function exists. Additionally, we provide evidence that our scheme is unspendable.

Initially, a $\kappa$-order multiplicative group $\mathbb{G}$ of order $q $ and a generator $g$ are selected and let the Common Random String be a random group element $h = g^y$ for some $y \in [q]$. Due to the self-reducibility of the DLOG problem, if DLOG is difficult in the group, an adversary will not be able to find the logarithm $y$ of the random group element, except with negligible probability.

Our scheme is illustrated in Algorithm~\ref{alg.construction-crs}. $\GenBurnAddr$ hashes the tag $t$ and treats $H(t)$ as the exponent, calculates the public key $g^{H(t)}$ and blinds it using the factor $h$. As before, $\BurnVerify$ regenerates the burn address from $t$ and ensures it has been calculated correctly.

\import{./}{algorithms/alg.construction-crs.tex}

Correctness holds unconditionally.

\begin{theorem}[Correctness]
  The Proof-of-Burn protocol $\Pi$ of Section~\ref{sec:standard} is \emph{correct}.
\end{theorem}
\begin{proof}
  Based on Algorithm~\ref{alg.construction-crs}, $\BurnVerify(1^\kappa, t, \GenBurnAddr(1^\kappa, t)) = \textsf{true}$ if and only if $\GenBurnAddr(1^\kappa, t) = \GenBurnAddr(1^\kappa, t)$, which always holds as $\GenBurnAddr$ is deterministic.
\end{proof}

As evidence towards unspendability, we now remark that it is difficult for an adversary to obtain the secret key corresponding to the public key $h g^{H(t)}$. We therefore conjecture that our scheme is unspendable.

\begin{lemma}[Logarithm unknowability]
  If $h$ is a \emph{Common Random String} and assuming the DLOG problem is hard, no probabilistic polynomial-time adversary can produce $(t, z)$ such that $g^z = h g^{H(t)}$, except with negligible probability in $\kappa$.
\end{lemma}
\begin{proof}
  Suppose $\mathcal{A}$ is a probabilistic polynomial-time adversary which produces $(t, z)$ with probability of success $p = \Pr[g^z = h g^{H(t)}]$.
  We construct the adversary $\mathcal{A}^*$ which invokes $\mathcal{A}$
  illustrated in Algorithm~\ref{alg.secret-key-adversary} and finds the
  logarithm of $h$.
  Conditioned on the event that $\mathcal{A}$ is successful,
  we have that
  $g^z = h g^{H(t)} \Rightarrow g^z = g^{y + H(t)} \Rightarrow y \equiv z - H(t) \Mod{q}$, so $\mathcal{A}^*$ is successful.
  Therefore $\Pr[\mathcal{A}^*(h) = y] = p$.
  But $\Pr[\mathcal{A}^*(h) = y]$ is negligible.
\end{proof}

This observation illustrates the useful fact that, if a single group element with unknowable logarithm is provided, an arbitrary number of such group elements can be found and proven to have unknowable logarithms.
